var documenterSearchIndex = {"docs":
[{"location":"#MQTT.jl-1","page":"MQTT.jl","title":"MQTT.jl","text":"","category":"section"},{"location":"#","page":"MQTT.jl","title":"MQTT.jl","text":"Modules = [MQTT]","category":"page"},{"location":"#MQTT.Client","page":"MQTT.jl","title":"MQTT.Client","text":"Client(on_message, on_disconnect, [ping_timeout=60])\n\nThe client struct is used to store state for a MQTT session\n\nArguments\n\non_message::Function: function to be called upon receiving a publish message\non_disconnect::Function: function to be called when disconnected\nping_timeout::UInt64=60: seconds the client waits for the PINGRESP   after sending a PINGREQ before he disconnects\n\n\n\n\n\n","category":"type"},{"location":"#MQTT.ConnectOpts","page":"MQTT.jl","title":"MQTT.ConnectOpts","text":"ConnectOpts(host, [port=1883]; <keyword arguments>)\nConnectOpts(get_io; <keyword arguments>)\n\nCreate a ConnectOpts using the given hostname and port of the broker.\n\nArguments\n\nhost::AbstractString: host of the broker\nport::Integer=1883: port of the broker\n\nget_io::Function: function to create a new IO object (e.g. a TCPSocket)\n\nKeywords\n\nusername::Union{Nothing, String} = nothing: username as a UTF-8 string\npassword::Union{Nothing, Vector{UInt8}} = nothing: password as a vector of bytes\nclient_id::String = \"\": client id as a UTF-8 string.   Zero-length string as an id is valid per MQTT 3.1.1 spec\nclean_session::Bool = true: discard any stored session and create a new one\nkeep_alive::UInt16 = 0x0000: set maximum keep alive interval\nwill::Union{Nothing, Message} = nothing: a Message containing a will\n\nExamples\n\nopts = ConnectOpts(\n    \"localhost\";\n    username=\"myuser\",\n    password=Vector{UInt8}(\"secretpassword\"),\n    client_id=\"my_mqtt_client\"\n)\n\n\n\n\n\n","category":"type"},{"location":"#MQTT.Message","page":"MQTT.jl","title":"MQTT.Message","text":"Message(topic, payload; [dup=false], [qos=AT_MOST_ONCE], [retain=false])\n\nA container for a message with all required metadata.\n\nCan be used as a last will message.\n\nArguments\n\ntopic::String\npayload::Vector{UInt8}\n\nKeywords\n\ndup::Bool: message is a duplicate\nqos::QoS: QoS level with which the message should be send\nretain::Bool: broker should retain the message\n\n\n\n\n\n","category":"type"},{"location":"#Base.get-Tuple{Distributed.Future}","page":"MQTT.jl","title":"Base.get","text":"get(future)\n\nConnects the Client instance using the given options.\n\n\n\n\n\n","category":"method"},{"location":"#MQTT.disconnect","page":"MQTT.jl","title":"MQTT.disconnect","text":"disconnect(client, [reason=nothing])\n\nDisconnects the Client instance gracefully, shuts down the background tasks and stores session state.\n\nArguments\n\nclient::Client: client to disconnect\nreason::Union{Exception,Nothing}=nothing: reason for the disconnect   This is forwarded to the on_disconnect callback\n\n\n\n\n\n","category":"function"},{"location":"#MQTT.publish-Tuple{Client,AbstractString,Array{UInt8,1}}","page":"MQTT.jl","title":"MQTT.publish","text":"publish(client, topic, payload; <keyword arguments>)\n\nPublishes a message to the broker connected to the Client instance provided as a parameter.\n\nArguments\n\nclient::Client: The client to send the message over.\ntopic::String: The topic to publish on.   Normal rules for publish topics apply so \"/\" are allowed but no wildcards.\npayload::Union{String, Vector{UInt8}}: payload to deliver.   This should be a Vector{UInt8}. String is automatically converted.   A zero length payload is allowed.\n\nKeywords\n\nasync::Bool=false: If false the call blocks until the operation is complete.\nqos::QoS=AT_MOST_ONCE: The MQTT quality of service to use for the message.   This has to be a QoS constant (ATMOSTONCE, ATLEASTONCE, EXACTLY_ONCE).\nretain::Bool=false: Whether or not the message should be retained by the broker.   This means the broker sends it to all clients who subscribe to this topic\n\n\n\n\n\n","category":"method"},{"location":"#MQTT.subscribe-Tuple{Client,Vararg{Tuple{String,MQTT.QoS},N} where N}","page":"MQTT.jl","title":"MQTT.subscribe","text":"subscribe(client, topics...; [async=false])\nsubscribe(client, topics...; [qos=AT_MOST_ONCE], [async=false])\n\nSubscribes the Client instance, provided as a parameter, to the specified topics.\n\nArguments\n\nclient::Client: the client to subscribe to the topics\ntopics...: Topics to connect to.   This can either be a list of Tuple{String, QoS} where the first element is a topic   name and the second a QoS level, or a list of String topic names (AT_MOST_ONCE is implied unless otherwise specified with the qos::QoS keyword)\n\nKeywords\n\nasync::Bool=false: If false the call blocks until the operation is complete\nqos::QoS=AT_MOST_ONCE: QoS level to subscribe with\n\n\n\n\n\n","category":"method"},{"location":"#MQTT.unsubscribe-Tuple{Client,Vararg{AbstractString,N} where N}","page":"MQTT.jl","title":"MQTT.unsubscribe","text":"unsubscribe(client, topics...; [async=false])\n\nThis method unsubscribes the Client instance from the specified topics.\n\nArguments\n\nclient::Client: the client to unsubscribe from the topics\ntopics::String...: list of topics to unsubscribe from\n\nKeywords\n\nasync::Bool=false: If false the call blocks until the operation is complete.\n\n\n\n\n\n","category":"method"},{"location":"#Sockets.connect-Tuple{Client,ConnectOpts}","page":"MQTT.jl","title":"Sockets.connect","text":"connect(client, opts; [async=false])\n\nConnects to a broker using the specified options.\n\nArguments\n\nclient::Client: client needs to be instantiated before connecting, but can be   reconnected using connect\nopts::ConnectOpts: connection options to be used\n\nKeywords\n\nasync::Bool: if true a Future is returned, therwise the function blocks until   the client is connected or the operation failed.\n\nSee also get.\n\n\n\n\n\n","category":"method"}]
}
